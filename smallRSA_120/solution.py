e = 165528674684553774754161107952508373110624366523537426971950721796143115780129435315899759675151336726943047090419484833345443949104434072639959175019000332954933802344468968633829926100061874628202284567388558408274913523076548466524630414081156553457145524778651651092522168245814433643807177041677885126141
n = 380654536359671023755976891498668045392440824270475526144618987828344270045182740160077144588766610702530210398859909208327353118643014342338185873507801667054475298636689473117890228196755174002229463306397132008619636921625801645435089242900101841738546712222819150058222758938346094596787521134065656721069
c = 106736634956713423171880243458860853614923436408403910756435046503192898024240611190855997949070256745640364108540939045479361457554316607017571153468476690496357063886824953242318826415477033865020127462206520914256550963389100920760453617865662232118987965851577854098830267901585424161112313772980331722305

p = 19497970535589906764765621427295002043018445459943056086713403490870298425506745856507678643916767475308508339457387394127356276232819283645070002029062741
q = 19522777289300812114803295910737999164581797480395400391273940665001088315424850264876083829310480274633915242605505486054722843889535421021671384821660409

from RSAwienerHacker import hack_RSA

d = hack_RSA(e, n)

print hex(pow(c, d, n))[2:-1].decode("hex")

"""
We're given a public exponent that is extremely large, which in turn will result in a private exponent that
is much smaller. RSA is vulnerable to Wiener's attack, if d < N^0.25 / 3.

Using a script online, we can calculate d from e and n.
https://github.com/pablocelayes/rsa-wiener-attack

$ python solution.py
flag{Are_any_RSA_vals_good_47293777497}
"""
